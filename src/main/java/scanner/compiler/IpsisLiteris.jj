options {
    STATIC = false;
    IGNORE_CASE = true;
    OUTPUT_DIRECTORY = "src/main/java/scanner/compiler/build";
    UNICODE_INPUT = true;
}

PARSER_BEGIN(IpsisLiteris)
package scanner.compiler.build;

import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.LinkedList;
import java.util.List;

import lombok.Getter;
import scanner.compiler.errors.AnalyserError;
import scanner.compiler.errors.ErrorMessage;
import scanner.compiler.errors.Log;

public class IpsisLiteris {

    public static void main (String[] args) throws ParseException, TokenMgrError {
        IpsisLiteris parser = new IpsisLiteris(System.in);
        parser.Program();
    }

    public static String compile(InputStream inputStream) throws ParseException, IOException {
        IpsisLiteris parser = new IpsisLiteris(inputStream);
        parser.Lexic();
        Log log = Log.getInstance();
        if(log.hasError()){
            return log.toString();
        }
        inputStream.reset();
        parser = new IpsisLiteris(inputStream);
        parser.Program();
        return (log.hasError()) ? log.toString() : "Programa compilado com sucesso!!! :D";
    }

    private void skipUntil(int type) {
        Token t = getToken(1);
        while (t.kind != type) {
            getNextToken();
            t = getToken(1);
        }
    }

}

PARSER_END(IpsisLiteris)

// Ignorados
SKIP: {"\n" | "\r" | "\r\n" | " " | "\t" | "\f" }
SKIP : {
    ":{" : COMMENT                     |
    <COMMENT_LINE: ":_" <LINE> >       |
    <#LINE: (~["\n", "\r"])* ("\n" | "\r" | "\n\r" | "\r\n")  >
}
<COMMENT> SKIP : {
    "}:" : DEFAULT
}
<COMMENT> MORE : {
    <~[]>
}

// Palavras reservadas
TOKEN : {
    <DEF: ("program"){1} > | <DATA_DEF: ("define"){1} > |
    <IS: ("is"){1} > | <EXE: ("execute"){1}> |

    <VAR: ("variable"){1} > | <NOT_VAR: ("not"){1}> | <SET: ("set"){1} > |
    <TO: ("to"){1} > | <GET: ("get"){1} >  | <PUT: ("put"){1}> |

    <NAT: ("natural"){1} > |  <REAL: ("real"){1} > | < CHAR: ("char"){1} > |
    <BOOL: ("boolean"){1} > | <TRUE: ("true"){1} > | <FALSE: ("false"){1} > |

    <WHILE: ("while"){1} > | <LOOP: ("loop"){1} > | <DO: ("do"){1} > |
    <IF: ("verify"){1} >
}

// Símbolos
TOKEN : {
    // Agregadores
    <OPEN_CURLY: ("{"){1} > | <CLOSE_CURLY: ("}"){1} >   |
    <OPEN_PARENT: ("("){1} > | <CLOSE_PARENT: (")"){1} > |
    <OPEN_SQUARE: ("["){1} > | <CLOSE_SQUARE: ("]"){1} > |

    // Comparadores
    <EQUAL: ("=="){1} > | <N_EQUAL: ("!="){1} > | <GREATER: (">"){1} >  |
    <LOWER: ("<"){1} > | <LOW_EQ: (">="){1} > | <GREAT_EQ: ("<="){1} >  |

    // Operadores Aritméticos
    <PLUS: ("+"){1} > | <MINUS: ("-"){1} > | <TIMES: ("*"){1} >         |
    <DIVIDE: ("/"){1} > | <POWER: ("**"){1} > | <INT_DIVIDE: ("%"){1} > |
    <MOD: ("%%"){1} > |

    // Operadores Lógicos
    <AND: ("&"){1} > | <OR: ("|"){1} > | <NOT: ("!"){1} > |

    // Simbolos especiais
    <DELIMITER: ("."){1} > | <SEPARATOR: (","){1} > | <HEADER_DEF: (":-"){1}>

}

// Identificadores
TOKEN : {
    <IDENTIFIER: (("_" | <LETTER>) (<LETTER>)* (<DPATH>)? ) |
                 (("_")? (<LETTER>)+ (<UPATH>))> |

    <#DPATH: <DIGIT> ((<LETTER>)* "_" (<LETTER>)* <DIGIT> | (<LETTER>)+ <DIGIT> )*
                     ((<LETTER>)+ | "_")+ > |

    <#UPATH: "_" ((<LETTER>)* <DIGIT> (<LETTER>)* "_" | (<DIGIT>)? (<LETTER>)+ ("_")?)* > |

    <#LETTER: ["A" - "Z"] | ["a" - "z"]>

}

// Constantes numéricas
TOKEN: {
    <INTEGER: <NUMS> (<DIGIT>)? >                        |
    <FLOAT: <INTEGER> (<DIGIT>)? (<DIGIT>)? "." <NUMS> > |
    <#DIGIT: ["0" - "9"] >                               |
    <#NUMS: <DIGIT> (<DIGIT>)? >
}

// Constantes literais
TOKEN : {
    <LITERAL: <SIMPLE_Q_STRING> | <DOUBLE_Q_STRING> >        |
    <#SIMPLE_Q_STRING: "'" (~["'"] | <ESCAPE_SQ> )* "'">     |
    <#DOUBLE_Q_STRING: "\"" (~["\""] | <ESCAPE_DQ> )* "\"" > |
    <#ESCAPE_DQ: "\\" "\"">                                     |
    <#ESCAPE_SQ: "\\" "'">
}

// Tokens inválidos
SPECIAL_TOKEN : {
    <INVALID_TOKEN: <NOT_TOKENS> | <INVALID_COLON> >
    {
        Log.getInstance().add(new AnalyserError(jjFillToken(), ErrorMessage.INVALID_TOKEN));
    } |

    <#NOT_TOKENS: (~["a"-"z", "A"-"Z", "+", "-", "*", "/", "%", "0"-"9", "{", "}", "(", ")", "[", "]", "\"",
    "'", "_", ".", ",", "\n", "\r", "\t", " "])> |
    <#INVALID_COLON: ":" (~["{", "-", "\n", "\r", "\t", " "]) >
}

//Analisador Sintático

void Program ():
{}
{
    (<HEADER_DEF> <LITERAL>)?
    <DEF> <OPEN_CURLY>
    VarDeclaration()
    ProgMain()
    <CLOSE_CURLY>
    (<IDENTIFIER>)?
}

void VarDeclaration ():
{}
{
    (<DATA_DEF> <OPEN_CURLY>
    VarField()
    <CLOSE_CURLY>)?
}

void VarField ():
{}
{
    ConstDef() (VarDef())? | VarDef() (ConstDef())?
}

void ConstDef ():
{}
{
    <NOT_VAR> <VAR> (Type() <IS> IdList() Constants() <DELIMITER>)+
}

void VarDef():
{}
{
    <VAR> (Type() <IS> IdList() <DELIMITER>)+
}

void ProgMain ():
{}
{
    <EXE> <OPEN_CURLY> CommandList() <CLOSE_CURLY> |
    {
        Log.getInstance().add(new AnalyserError(getToken(1), ErrorMessage.INVALID_TOKEN));
    }
}

void Command ():
{}
{
    While() | DoWhile() | Read() | Print() | Select() | Attribution()
}

void Attribution ():
{}
{
    <SET> Expression() <TO> IdList()
}

void Select ():
{}
{
    <IF> Expression() <IS> (
        IsTrue() (IsFalse())? | IsFalse() (IsTrue())?
    )
}

void IsTrue ():
{}
{
    <TRUE> <OPEN_CURLY> CommandList() <CLOSE_CURLY>
}

void IsFalse ():
{}
{
    <FALSE> <OPEN_CURLY> CommandList() <CLOSE_CURLY>
}

void Print ():
{}
{
    <PUT> <OPEN_CURLY> Value() <CLOSE_CURLY>
}

void Read ():
{}
{
    <GET> <OPEN_CURLY> IdList() <CLOSE_CURLY>
}

void DoWhile ():
{}
{
    <LOOP> <OPEN_CURLY> CommandList() <CLOSE_CURLY> <WHILE> Expression() <IS> <TRUE>
}

void While ():
{}
{
    <WHILE> Expression() <IS> <TRUE> <DO> <OPEN_CURLY> CommandList() <CLOSE_CURLY>
}

// Sintático Úteis

void Constants ():
{}
{
    try{
        <LITERAL> | <INTEGER> | <FLOAT> | <TRUE> | <FALSE>
    } catch (ParseException e){
        Log.getInstance().add(new AnalyserError(getToken(1), ErrorMessage.MISSING,
                List.of(LITERAL, INTEGER, FLOAT, TRUE, FALSE)));
    }
}

void Value():
{}
{
    Id() | Constants()
}

void Id():
{}
{
    <IDENTIFIER> (<OPEN_SQUARE> <INTEGER> <CLOSE_SQUARE>)?
}

void Type():
{}
{
    <NAT> | <REAL> | <CHAR> | <BOOL>
}

void IdList():
{}
{
    Id() (<SEPARATOR> Id())*
}

void CommandList ():
{}
{
    (
    Command() (<DELIMITER> | {
        Log.getInstance().add(new AnalyserError(getToken(1), ErrorMessage.INVALID_TOKEN));
    })
    )+
}

void Expression ():
{}
{
    ExpLogicAritmetic() (Comparator() ExpLogicAritmetic())?
}

void ExpLogicAritmetic ():
{}
{
    Element2() (LowPriorityOperator() Element2())*
}

void Element2 ():
{}
{
    Element1() (MediumPriorityOperator() Element1())*
}

void Element1 ():
{}
{
     Element() ( <POWER> Element())*
}

void Element ():
{}
{
    Value() | ParentesisExp() | <NOT> ParentesisExp()
}

void ParentesisExp ():
{}
{
    <OPEN_PARENT> Expression() <CLOSE_PARENT>
}

void Comparator ():
{}
{
    <EQUAL> | <N_EQUAL> | <LOWER> | <GREATER> | <LOW_EQ> | <GREAT_EQ>
}

void LowPriorityOperator ():
{}
{
    <PLUS> | <MINUS> | <OR>
}

void MediumPriorityOperator ():
{}
{
    <TIMES> | <DIVIDE> | <INT_DIVIDE> | <MOD> | <AND>
}


// Analisador Léxico

void Lexic():
{}
{
   (token())*
}

void token():
{}
{
    // palavras reservadas
     <DEF> | <DATA_DEF> | <IS> | <EXE> | <VAR> | <NOT_VAR> | <SET> | <TO> |
     <GET> | <PUT> | <NAT> | <REAL> | <CHAR> | <BOOL> | <TRUE> | <FALSE> |
     <WHILE> | <LOOP> | <DO> | <IF> |

     // Agregadores
     <OPEN_CURLY> | <CLOSE_CURLY> | <OPEN_PARENT> | <CLOSE_PARENT> | <OPEN_SQUARE> |
     <CLOSE_SQUARE> |

     // Comparadores
     <EQUAL> | <N_EQUAL> | <GREATER> | <LOWER> | <LOW_EQ> | <GREAT_EQ> |

     // Operadores Aritméticos
     <PLUS> | <MINUS> | <TIMES> | <DIVIDE> | <POWER> | <INT_DIVIDE> | <MOD> |

     // Operadores Lógicos
     <AND> | <OR> | <NOT> |

     // Simbolos especiais
     <DELIMITER> | <SEPARATOR> | <HEADER_DEF> |

     // Identificador
     <IDENTIFIER> |

     // Constantes
     <INTEGER> | <FLOAT> | <LITERAL>
}





