options {
    STATIC = false;
    IGNORE_CASE = true;
    OUTPUT_DIRECTORY = "src/main/java/scanner/compiler/build";
}

PARSER_BEGIN(IpsisLiteris)
package scanner.compiler.build;

import java.util.LinkedList;
import java.util.List;

public class IpsisLiteris {

    private List<AnalyserError> result = new LinkedList<>();

    public static void main (String[] args) throws ParseException, TokenMgrError {
        IpsisLiteris parser = new IpsisLiteris(System.in);
        parser.Program();
        /*for (AnalyserResult analyser : parser.result) {
            System.out.println(analyser);
        }*/
    }

    public static class AnalyserError {

        public final String token;
        public final int line;
        public final int column;
        public final String type;
        public final int id;
        public final String errorMsg;

        private AnalyserError (Token t, String errorMsg) {
            token = t.image;
            line = t.beginLine;
            column = t.beginColumn;
            type = IpsisLiterisConstants.tokenImage[t.kind];
            id = t.kind;
            this.errorMsg = errorMsg;
        }

        @Override
        public String toString() {
            return errorMsg + " at line: " + line + " at column: " + column;
        }
    }
}

PARSER_END(IpsisLiteris)

// Ignorados
SKIP: {"\n" | "\r" | "\r\n" | " " | "\t" | "\f" }
SKIP : {
    ":{" : COMMENT                     |
    <COMMENT_LINE: ":_" <LINE> >       |
    <#LINE: (~["\n", "\r"])* ("\n" | "\r" | "\n\r" | "\r\n")  >
}
<COMMENT> SKIP : {
    "}:" : DEFAULT
}
<COMMENT> MORE : {
    <~[]>
}

// Palavras reservadas
TOKEN : {
    <DEF: ("program"){1} > | <DATA_DEF: ("define"){1} > |
    <IS: ("is"){1} > | <EXE: ("execute"){1}> |

    <VAR: ("variable"){1} > | <NOT_VAR: ("not"){1}> | <SET: ("set"){1} > |
    <TO: ("to"){1} > | <GET: ("get"){1} >  | <PUT: ("put"){1}> |

    <NAT: ("natural"){1} > |  <REAL: ("real"){1} > | < CHAR: ("char"){1} > |
    <BOOL: ("boolean"){1} > | <TRUE: ("true"){1} > | <FALSE: ("false"){1} > |

    <WHILE: ("while"){1} > | <LOOP: ("loop"){1} > | <DO: ("do"){1} > |
    <IF: ("verify"){1} >
}

// Símbolos
TOKEN : {
    // Agregadores
    <OPEN_CURLY: ("{"){1} > | <CLOSE_CURLY: ("}"){1} >   |
    <OPEN_PARENT: ("("){1} > | <CLOSE_PARENT: (")"){1} > |
    <OPEN_SQUARE: ("["){1} > | <CLOSE_SQUARE: ("]"){1} > |

    // Comparadores
    <EQUAL: ("=="){1} > | <N_EQUAL: ("!="){1} > | <GREATER: (">"){1} >  |
    <LOWER: ("<"){1} > | <LOW_EQ: (">="){1} > | <GREAT_EQ: ("<="){1} >  |

    // Operadores Aritméticos
    <PLUS: ("+"){1} > | <MINUS: ("-"){1} > | <TIMES: ("*"){1} >         |
    <DIVIDE: ("/"){1} > | <POWER: ("**"){1} > | <INT_DIVIDE: ("%"){1} > |
    <MOD: ("%%"){1} > |

    // Operadores Lógicos
    <AND: ("&"){1} > | <OR: ("|"){1} > | <NOT: ("!"){1} > |

    // Simbolos especiais
    <DELIMITER: ("."){1} > | <SEPARATOR: (","){1} > | <HEADER_DEF: (":-"){1}>

}

// Identificadores
TOKEN : {
    <IDENTIFIER: (("_" | <LETTER>) (<LETTER>)* (<DPATH>)? ) |
                 (("_")? (<LETTER>)+ (<UPATH>))> |

    <#DPATH: <DIGIT> ((<LETTER>)* "_" (<LETTER>)* <DIGIT> | (<LETTER>)+ <DIGIT> )*
                     ((<LETTER>)+ | "_")+ > |

    <#UPATH: "_" ((<LETTER>)* <DIGIT> (<LETTER>)* "_" | (<DIGIT>)? (<LETTER>)+ ("_")?)* > |

    <#LETTER: ["A" - "Z"] | ["a" - "z"]>

}

// Constantes numéricas
TOKEN: {
    <INTEGER: <NUMS> (<DIGIT>)? >                        |
    <FLOAT: <INTEGER> (<DIGIT>)? (<DIGIT>)? "." <NUMS> > |
    <#DIGIT: ["0" - "9"] >                               |
    <#NUMS: <DIGIT> (<DIGIT>)? >
}

// Constantes literais
TOKEN : {
    <LITERAL: <SIMPLE_Q_STRING> | <DOUBLE_Q_STRING> >        |
    <#SIMPLE_Q_STRING: "'" (~["'"] | <ESCAPE_SQ> )* "'">     |
    <#DOUBLE_Q_STRING: "\"" (~["\""] | <ESCAPE_DQ> )* "\"" > |
    <#ESCAPE_DQ: "\\" "\"">                                     |
    <#ESCAPE_SQ: "\\" "'">
}

//Analisador Sintático

void Program ():
{}
{
    (<HEADER_DEF> <LITERAL>)?
    <DEF> <OPEN_CURLY>
    VarDeclaration()
    ProgMain()
    <CLOSE_CURLY>
    (<IDENTIFIER>)?
}

void VarDeclaration ():
{}
{
    (<DATA_DEF> <OPEN_CURLY>
    VarField()
    <CLOSE_CURLY>)?
}

void VarField ():
{}
{
    ConstDef() (VarDef())? | VarDef() (ConstDef())?
}

void ConstDef ():
{}
{
    <NOT_VAR> <VAR> Type() <IS> (IdList() Constants() <DELIMITER>)+
}

void VarDef():
{}
{
    <VAR> (Type() <IS> IdList() <DELIMITER>)+
}

void ProgMain ():
{}
{
    <EXE> <OPEN_CURLY> CommandList() |
    {
        result.add(new AnalyserError(getToken(1), "ErRo"));
        System.out.println(result);
    }
}

void Command ():
{}
{
    While() | DoWhile() | Read() | Print() | Select() | Attribution()
}

void Attribution ():
{}
{
    <SET> Expression() <TO> IdList()
}

void Select ():
{}
{
    <IF> Expression() <IS> (
        IsTrue() (IsFalse())? | IsFalse() (IsTrue())?
    )
}

void IsTrue ():
{}
{
    <TRUE> <OPEN_CURLY> CommandList() <CLOSE_CURLY>
}

void IsFalse ():
{}
{
    <FALSE> <OPEN_CURLY> CommandList() <CLOSE_CURLY>
}

void Print ():
{}
{
    <PUT> <OPEN_CURLY> Value() <CLOSE_CURLY>
}

void Read ():
{}
{
    <GET> <OPEN_CURLY> IdList() <CLOSE_CURLY>
}

void DoWhile ():
{}
{
    <LOOP> <OPEN_CURLY> CommandList() <CLOSE_CURLY> <WHILE> Expression() <IS> <TRUE>
}

void While ():
{}
{
    <WHILE> Expression() <IS> <TRUE> <DO> <OPEN_CURLY> CommandList() <CLOSE_CURLY>
}

// Sintático Úteis

void Constants ():
{}
{
    <LITERAL> | <INTEGER> | <FLOAT> | <TRUE> | <FALSE>
}

void Value():
{}
{
    <IDENTIFIER> (<OPEN_SQUARE> <INTEGER> <CLOSE_SQUARE>)? | Constants()
}

void Type():
{}
{
    <NAT> | <REAL> | <CHAR> | <BOOL>
}

void IdList():
{}
{
    <IDENTIFIER> (<SEPARATOR> <IDENTIFIER>)*
}

void CommandList ():
{}
{
    (Command() <DELIMITER>)+
}

void Expression ():
{}
{
    ExpLogicAritmetic() (Comparator() ExpLogicAritmetic())?
}

void ExpLogicAritmetic ():
{}
{
    Element2() (LowPriorityOperator() Element2())*
}

void Element2 ():
{}
{
    Element1() (MediumPriorityOperator() Element1())*
}

void Element1 ():
{}
{
     Element() ( <POWER> Element())*
}

void Element ():
{}
{
    Value() | ParentesisExp() | <NOT> ParentesisExp()
}

void ParentesisExp ():
{}
{
    <OPEN_PARENT> Expression() <CLOSE_PARENT>
}

void Comparator ():
{}
{
    <EQUAL> | <N_EQUAL> | <LOWER> | <GREATER> | <LOW_EQ> | <GREAT_EQ>
}

void LowPriorityOperator ():
{}
{
    <PLUS> | <MINUS> | <OR>
}

void MediumPriorityOperator ():
{}
{
    <TIMES> | <DIVIDE> | <INT_DIVIDE> | <MOD> | <AND>
}



// Analisador Léxico

/*List<AnalyserResult> Lexic():
{
   List<AnalyserResult> result = new LinkedList<>();
   AnalyserResult input;
}
{
    (
       input = token()
       {
           result.add(input);
       }
    )*
    <EOF>
    {return result;}

}

AnalyserResult token():
{
    Token t;
    String msg;
}
{
    (
    t = <FLOAT> | t = <INTEGER> | t = <LITERAL> |

    t = <IDENTIFIER> |

    t = <LOOP> | t = <NAT> | t = <REAL> | t = <IF> | t = <DEF> |
    t = <DATA_DEF> | t = <BOOL> | t = <EXE> | t = <IS> |
    t = <SET> | t = <NOT_VAR> | t = <GET> | t = <TO> | t = <VAR> |
    t = <TRUE> | t = <FALSE> | t = <WHILE> | t = <DO> | t = <CHAR>
    )
    {return new AnalyserResult(t);} |
     t = <(~[])> { msg = "TOKEN INVALIDO"; }
     { return AnalyserResult.error(t, msg); }
}*/





