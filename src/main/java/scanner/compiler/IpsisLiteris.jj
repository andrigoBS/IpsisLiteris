options {
    STATIC = false;
    IGNORE_CASE = true;
    OUTPUT_DIRECTORY = "src/main/java/scanner/compiler/build";
}

PARSER_BEGIN(IpsisLiteris)
package scanner.compiler.build;

import java.util.LinkedList;
import java.util.List;

public class IpsisLiteris {

    private List<AnalyserResult> result;

    public static void main (String[] args) throws ParseException, TokenMgrError {
        IpsisLiteris parser = new IpsisLiteris(System.in);
        parser.result = parser.Start();
        for (AnalyserResult analyser : parser.result) {
            System.out.println(analyser);
        }
    }

    public static class AnalyserResult {

        public final String token;
        public final int line;
        public final int column;
        public final String type;
        public final int id;
        public final boolean error;
        public final String errorMsg;

        private AnalyserResult (Token t, boolean error, String errorMsg) {
            token = t.image;
            line = t.beginLine;
            column = t.beginColumn;
            type = IpsisLiterisConstants.tokenImage[t.kind];
            id = t.kind;
            this.error = error;
            this.errorMsg = errorMsg;
        }

        public AnalyserResult (Token t) { this(t, false, ""); }

        public static AnalyserResult error (Token t, String msg) {
            return new AnalyserResult(t, true, msg);
        }

        @Override
        public String toString() {
            if (!error) return token + " " + line + " " + column + " " + type + " " + id;
            return errorMsg + " at line: " + line + " at column: " + column;
        }
    }
}

PARSER_END(IpsisLiteris)

// Ignorados
SKIP: {"\n" | "\r" | "\r\n" | " " | "\t" | "\f" }
SKIP : {
    ":{" : COMMENT                     |
    <COMMENT_LINE: ":_" <LINE> >       |
    <#LINE: (~["\n", "\r"])* ("\n" | "\r" | "\n\r" | "\r\n")  >
}
<COMMENT> SKIP : {
    "}:" : DEFAULT
}
<COMMENT> MORE : {
    <~[]>
}

// Palavras reservadas
TOKEN : {
    <DEF: ("program"){1} > | <DATA_DEF: ("define"){1} > |
    <IS: ("is"){1} > | <EXE: ("execute"){1}> |

    <VAR: ("variable"){1} > | <NOT_VAR: ("not"){1}> | <SET: ("set"){1} > |
    <TO: ("to"){1} > | <GET: ("get"){1} >  |

    <NAT: ("natural"){1} > |  <REAL: ("real"){1} > | < CHAR: ("char"){1} > |
    <BOOL: ("boolean"){1} > | <TRUE: ("true"){1} > | <FALSE: ("false"){1} > |

    <WHILE: ("while"){1} > | <LOOP: ("loop"){1} > | <DO: ("do"){1} > |
    <IF: ("verify"){1} >
}

// Símbolos
TOKEN : {

    <SPECIAL_SYMBOL:
        // Agregadores
        "{" | "}" | "(" | ")" | "[" | "]" |

        // Comparadores
        "==" | "!=" | ">" | "<" | ">=" | "<=" |

        // Op. Aritméticos
        "+" | "-" | "*" | "/" | "%" | "**" | "%%" |

        // Op. Lógicos
        "&" | "|" | "!"

        // Especiais
        "." | "," | ":-"
    >

}

// Identificadores
TOKEN : {
    <IDENTIFIER: (("_" | <LETTER>) (<LETTER>)* (<DPATH>)? ) |
                 (("_")? (<LETTER>)+ (<UPATH>))> |

    <#DPATH: <DIGIT> ((<LETTER>)* "_" (<LETTER>)* <DIGIT> | (<LETTER>)+ <DIGIT> )*
                     ((<LETTER>)+ | "_")+ > |

    <#UPATH: "_" ((<LETTER>)* <DIGIT> (<LETTER>)* "_" | (<DIGIT>)? (<LETTER>)+ ("_")?)* > |

    <#LETTER: ["A" - "Z"] | ["a" - "z"]>

}

// Constantes numéricas
TOKEN: {
    <INTEGER: <NUMS> (<DIGIT>)? >                        |
    <FLOAT: <INTEGER> (<DIGIT>)? (<DIGIT>)? "." <NUMS> > |
    <#DIGIT: ["0" - "9"] >                               |
    <#NUMS: <DIGIT> (<DIGIT>)? >
}

// Constantes literais
TOKEN : {
    <LITERAL: <SIMPLE_Q_STRING> | <DOUBLE_Q_STRING> >        |
    <#SIMPLE_Q_STRING: "'" (~["'"] | <ESCAPE_SQ> )* "'">     |
    <#DOUBLE_Q_STRING: "\"" (~["\""] | <ESCAPE_DQ> )* "\"" > |
    <#ESCAPE_DQ: "\\" "\"">                                     |
    <#ESCAPE_SQ: "\\" "'">
}

//Analisador Sintático

void Program():
{}
{
    <DEF>
    (":-" )
}

// Analisador Léxico

List<AnalyserResult> Lexic():
{
   List<AnalyserResult> result = new LinkedList<>();
   AnalyserResult input;
}
{
    (
       input = token()
       {
           result.add(input);
       }
    )*
    <EOF>
    {return result;}

}

AnalyserResult token():
{
    Token t;
    String msg;
}
{
    (
    t = <FLOAT> | t = <INTEGER> | t = <LITERAL> |

    t = <SPECIAL_SYMBOL> |

    t = <IDENTIFIER> |

    t = <LOOP> | t = <NAT> | t = <REAL> | t = <IF> | t = <DEF> |
    t = <DATA_DEF> | t = <BOOL> | t = <EXE> | t = <IS> |
    t = <SET> | t = <NOT_VAR> | t = <GET> | t = <TO> | t = <VAR> |
    t = <TRUE> | t = <FALSE> | t = <WHILE> | t = <DO> | t = <CHAR>
    )
    {return new AnalyserResult(t);} |
     t = <(~[])> { msg = "TOKEN INVALIDO"; }
     { return AnalyserResult.error(t, msg); }
}





